# Подробное объяснение Dockerfile

## Общая концепция: Multi-stage build (многоэтапная сборка)

Dockerfile использует технику многоэтапной сборки для создания минимального финального образа.
Это позволяет:
- Использовать полный набор инструментов для сборки (builder stage)
- Создать минимальный финальный образ без инструментов разработки (final stage)
- Уменьшить размер финального образа в 5-10 раз

---

## ЭТАП 1: Builder (Сборка приложения)

### Строка 1: `FROM golang:1.25-alpine AS builder`
**Что делает:**
- Берет базовый образ `golang:1.25-alpine` (Go версии 1.25 на базе Alpine Linux)
- `alpine` - минималистичный Linux дистрибутив (~5MB), основанный на musl libc
- `AS builder` - дает имя этому этапу сборки, чтобы можно было ссылаться на него позже

**Почему Alpine:**
- Очень маленький размер образа
- Быстрая загрузка и запуск
- Безопасность (меньше поверхность атаки)

**Что внутри образа:**
- Компилятор Go
- Стандартная библиотека Go
- Инструменты для сборки

---

### Строка 3: `WORKDIR /app`
**Что делает:**
- Создает директорию `/app` в контейнере (если не существует)
- Устанавливает её как рабочую директорию для всех последующих команд
- Все команды (COPY, RUN, CMD) будут выполняться относительно этой директории

**Аналогия:** Как `cd /app` в терминале, но с автоматическим созданием директории

---

### Строка 5: `COPY go.mod ./`
**Что делает:**
- Копирует файл `go.mod` из вашей локальной директории в `/app/go.mod` контейнера
- `./` означает текущую рабочую директорию (которая была установлена как `/app`)

**Почему отдельно копируем go.mod:**
- Docker кэширует слои образа
- Если `go.mod` не изменился, Docker использует кэш и не пересобирает следующие слои
- Это ускоряет сборку при изменении только исходного кода

**Процесс:**
1. Docker проверяет, изменился ли `go.mod`
2. Если нет - использует кэш слоя
3. Если да - пересобирает с этого момента

---

### Строка 7: `RUN go mod download`
**Что делает:**
- Загружает все зависимости, указанные в `go.mod`
- Сохраняет их в кэш модулей Go внутри контейнера
- Не компилирует код, только скачивает зависимости

**Почему это отдельный шаг:**
- Если зависимости не изменились, этот шаг берется из кэша
- Экономит время при повторных сборках

**Что происходит внутри:**
```
go mod download
→ Читает go.mod
→ Скачивает все зависимости из интернета
→ Сохраняет в $GOPATH/pkg/mod
```

---

### Строка 9: `COPY . .`
**Что делает:**
- Копирует ВСЕ файлы из текущей локальной директории в `/app` контейнера
- Первая точка `.` - источник (локальная директория, где запускается docker build)
- Вторая точка `.` - назначение (рабочая директория контейнера `/app`)

**Что копируется:**
- Весь исходный код Go
- Все файлы проекта (кроме тех, что в .dockerignore)

**Важно:** Этот шаг выполняется ПОСЛЕ загрузки зависимостей, чтобы при изменении только кода не пересобирались зависимости

---

### Строка 11: `RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main ./cmd/main.go`
**Что делает:**
- Компилирует Go приложение в исполняемый бинарный файл

**Разбор флагов:**
- `CGO_ENABLED=0` - отключает CGO (интеграцию с C библиотеками)
  - Бинарник будет статически скомпилирован
  - Не будет зависеть от системных библиотек
  - Можно запускать на любом Linux без установки зависимостей
  
- `GOOS=linux` - явно указывает целевую ОС (Linux)
  - Обеспечивает кроссплатформенную сборку
  - Можно собирать на Mac/Windows для Linux
  
- `go build -a` - пересобирает все пакеты, даже если они не изменились
  - Гарантирует свежую сборку
  - Устраняет проблемы с кэшем
  
- `-installsuffix cgo` - добавляет суффикс к именам пакетов
  - Используется вместе с CGO_ENABLED=0
  - Разделяет пакеты с CGO и без
  
- `-o main` - имя выходного файла
  - Создаст файл `/app/main` в контейнере
  
- `./cmd/main.go` - точка входа приложения
  - Файл, с которого начинается компиляция

**Результат:**
- Создается статически скомпилированный бинарник `main`
- Размер обычно 10-30 MB
- Не требует Go runtime для запуска

---

## ЭТАП 2: Final (Финальный образ)

### Строка 13: `FROM alpine:latest`
**Что делает:**
- Начинает новый этап сборки с чистого образа Alpine Linux
- Это НЕ продолжение предыдущего этапа, а совершенно новый образ
- Предыдущий этап (builder) больше не нужен и будет удален

**Почему новый образ:**
- В builder остались инструменты разработки (Go компилятор, ~300MB)
- В финальном образе они не нужны
- Финальный образ будет содержать только:
  - Минимальный Alpine Linux (~5MB)
  - Скомпилированный бинарник
  - Необходимые системные библиотеки

**Размер:**
- Builder образ: ~300-400 MB
- Финальный образ: ~15-25 MB (в 15-20 раз меньше!)

---

### Строка 15: `RUN apk --no-cache add ca-certificates tzdata`
**Что делает:**
- Устанавливает необходимые системные пакеты через менеджер пакетов Alpine (apk)

**Разбор:**
- `apk` - менеджер пакетов Alpine (аналог apt для Ubuntu, yum для CentOS)
- `--no-cache` - не сохраняет кэш пакетов после установки
  - Уменьшает размер образа на ~5-10 MB
  - Кэш пакетов не нужен в runtime
  
- `ca-certificates` - корневые SSL сертификаты
  - Нужны для HTTPS запросов
  - Без них приложение не сможет делать запросы к внешним API по HTTPS
  
- `tzdata` - база данных часовых поясов
  - Нужна для корректной работы с датами и временем
  - Позволяет использовать timezone в приложении

**Альтернатива без --no-cache:**
```dockerfile
RUN apk add ca-certificates tzdata && \
    rm -rf /var/cache/apk/*
```
Но `--no-cache` проще и чище.

---

### Строка 17: `WORKDIR /root/`
**Что делает:**
- Устанавливает рабочую директорию `/root/` (домашняя директория root пользователя)
- Здесь будет находиться наш бинарник

**Почему /root/, а не /app:**
- В финальном образе не нужна структура проекта
- Нужен только один файл - бинарник
- `/root/` - стандартное место для приложений в контейнерах

---

### Строка 19: `COPY --from=builder /app/main .`
**Что делает:**
- Копирует скомпилированный бинарник из этапа builder в финальный образ

**Разбор:**
- `--from=builder` - указывает, откуда копировать (из этапа с именем "builder")
- `/app/main` - путь к файлу в builder контейнере
- `.` - текущая рабочая директория в финальном образе (`/root/`)
- Результат: `/root/main` в финальном образе

**Важно:**
- Это единственное, что копируется из builder
- Весь остальной "мусор" (исходники, зависимости, компилятор) остается в builder
- Builder этап удаляется после сборки

---

### Строка 21: `EXPOSE 3000`
**Что делает:**
- Декларативно указывает, что контейнер будет слушать порт 3000
- Это метаданные, не открывает порт автоматически

**Зачем нужно:**
- Документация для разработчиков
- Docker Compose и другие инструменты читают эту информацию
- Помогает понять, какие порты использует приложение

**Важно:**
- Это НЕ открывает порт автоматически
- Порт открывается через `-p` в `docker run` или `ports:` в docker-compose.yml

---

### Строка 23: `CMD ["./main"]`
**Что делает:**
- Указывает команду, которая выполнится при запуске контейнера
- `["./main"]` - exec форма (рекомендуется)

**Разбор:**
- `./main` - запускает бинарник `main` из текущей директории
- `[]` - exec форма (запускается напрямую, без shell)
  - PID 1 процесса будет сам бинарник
  - Сигналы (SIGTERM, SIGINT) будут правильно обрабатываться
  
**Альтернатива (shell форма, не рекомендуется):**
```dockerfile
CMD ./main
```
- Запускается через shell (/bin/sh)
- PID 1 будет shell, а не приложение
- Сигналы могут обрабатываться некорректно

**Что происходит при запуске:**
```bash
docker run <image>
→ Docker выполняет CMD ["./main"]
→ Запускается /root/main
→ Приложение начинает работать
```

---

## Визуализация процесса сборки

```
┌─────────────────────────────────────┐
│  ЭТАП 1: Builder                    │
│  FROM golang:1.25-alpine            │
│  ┌───────────────────────────────┐  │
│  │ • Go компилятор               │  │
│  │ • Исходный код                │  │
│  │ • Зависимости                 │  │
│  │ • Скомпилированный бинарник   │  │
│  └───────────────────────────────┘  │
│  Размер: ~350 MB                     │
└─────────────────────────────────────┘
              │
              │ COPY --from=builder /app/main
              ▼
┌─────────────────────────────────────┐
│  ЭТАП 2: Final                       │
│  FROM alpine:latest                  │
│  ┌───────────────────────────────┐  │
│  │ • Минимальный Alpine          │  │
│  │ • ca-certificates             │  │
│  │ • tzdata                      │  │
│  │ • Бинарник main               │  │
│  └───────────────────────────────┘  │
│  Размер: ~20 MB                      │
└─────────────────────────────────────┘
```

---

## Преимущества многоэтапной сборки

1. **Маленький размер образа** - только необходимое
2. **Быстрая загрузка** - меньше данных для скачивания
3. **Безопасность** - меньше поверхность атаки (нет компилятора, исходников)
4. **Производительность** - быстрый запуск контейнера
5. **Экономия ресурсов** - меньше места на диске

---

## Как это работает на практике

### Сборка образа:
```bash
docker build -t finance-backend .
```

**Процесс:**
1. Docker читает Dockerfile
2. Создает builder контейнер с Go
3. Копирует go.mod, скачивает зависимости
4. Копирует код, компилирует
5. Создает новый финальный контейнер с Alpine
6. Копирует только бинарник
7. Удаляет builder контейнер
8. Сохраняет финальный образ

### Запуск контейнера:
```bash
docker run -p 3000:3000 finance-backend
```

**Процесс:**
1. Docker создает контейнер из образа
2. Выполняет `CMD ["./main"]`
3. Приложение запускается на порту 3000
4. Доступно на localhost:3000

