# Подробное объяснение docker-compose.yml

## Общая концепция Docker Compose

Docker Compose - это инструмент для определения и запуска многоконтейнерных приложений.
Вместо запуска каждого контейнера отдельно командой `docker run`, вы описываете всю инфраструктуру в одном YAML файле.

**Преимущества:**
- Один файл для всей инфраструктуры
- Автоматическое управление сетями и volumes
- Простое масштабирование
- Управление зависимостями между сервисами

---

## СТРУКТУРА ФАЙЛА

### Строка 1: `services:`
**Что делает:**
- Начало секции определения сервисов (контейнеров)
- Каждый сервис - это отдельный контейнер, который будет запущен

**YAML структура:**
```yaml
services:          # Корневой ключ
  service1:        # Имя первого сервиса
    ...            # Настройки сервиса
  service2:        # Имя второго сервиса
    ...            # Настройки сервиса
```

---

## СЕРВИС 1: PostgreSQL

### Строка 2: `postgres:`
**Что делает:**
- Определяет сервис с именем `postgres`
- Это имя используется для:
  - Идентификации сервиса в docker-compose
  - Имя хоста в сети (другие сервисы могут обращаться как `postgres:5432`)
  - Префикс для имен ресурсов

**Важно:** Имя `postgres` становится hostname в Docker сети!

---

### Строка 3: `image: postgres:16-alpine`
**Что делает:**
- Указывает Docker образ для использования
- `postgres:16-alpine` - официальный образ PostgreSQL версии 16 на базе Alpine

**Разбор:**
- `postgres` - имя образа (из Docker Hub)
- `16` - версия PostgreSQL
- `alpine` - вариант на базе Alpine Linux (минимальный размер)

**Альтернативы:**
- `postgres:16` - стандартный образ (больше размер)
- `postgres:latest` - последняя версия (не рекомендуется для продакшена)

**Что внутри образа:**
- PostgreSQL сервер
- Инструменты для управления БД
- Скрипты инициализации

---

### Строка 4: `container_name: finance-dashboard-postgres`
**Что делает:**
- Задает конкретное имя контейнера
- Без этого Docker Compose создал бы имя: `backend_postgres_1`

**Зачем нужно:**
- Легче найти контейнер: `docker ps | grep finance-dashboard-postgres`
- Можно подключаться по имени: `docker exec -it finance-dashboard-postgres psql`
- Предсказуемое имя для скриптов и мониторинга

**Без container_name:**
```bash
docker ps
# backend_postgres_1    # Автоматическое имя
```

**С container_name:**
```bash
docker ps
# finance-dashboard-postgres    # Явное имя
```

---

### Строки 5-8: `environment:`
**Что делает:**
- Устанавливает переменные окружения внутри контейнера
- PostgreSQL использует эти переменные для настройки при первом запуске

**Разбор каждой переменной:**

#### `POSTGRES_USER: postgres`
- Создает пользователя БД с именем `postgres`
- Это суперпользователь (имеет все права)
- Используется для подключения к БД

**Как это работает:**
1. При первом запуске контейнера PostgreSQL проверяет переменную
2. Если БД еще не инициализирована - создает пользователя
3. Если БД уже существует - переменная игнорируется

#### `POSTGRES_PASSWORD: postgres`
- Устанавливает пароль для пользователя `postgres`
- **ВНИМАНИЕ:** В продакшене используйте секреты!

**Безопасность:**
```yaml
# Плохо (пароль в открытом виде)
POSTGRES_PASSWORD: postgres

# Хорошо (использование секретов)
POSTGRES_PASSWORD_FILE: /run/secrets/postgres_password
```

#### `POSTGRES_DB: dashboard`
- Создает базу данных с именем `dashboard`
- База создается автоматически при первом запуске
- Пользователь `postgres` получает полные права на эту БД

**Процесс инициализации:**
```
1. Контейнер запускается первый раз
2. PostgreSQL видит, что /var/lib/postgresql/data пуста
3. Инициализирует БД
4. Создает пользователя postgres с паролем postgres
5. Создает базу данных dashboard
6. Готово к работе!
```

---

### Строки 9-10: `ports:`
**Что делает:**
- Пробрасывает порты из контейнера на хост-машину
- Формат: `"HOST_PORT:CONTAINER_PORT"`

**Разбор:**
- `"5432:5432"` - порт хоста:порт контейнера
- Левый `5432` - порт на вашей машине (localhost:5432)
- Правый `5432` - порт внутри контейнера (стандартный порт PostgreSQL)

**Как это работает:**
```
┌─────────────────────────────────┐
│  Ваш компьютер                  │
│  localhost:5432 ────────────────┼──┐
└─────────────────────────────────┘  │
                                     │ Docker проброс портов
┌─────────────────────────────────┐  │
│  Контейнер PostgreSQL           │  │
│  postgres:5432 ◄────────────────┼──┘
└─────────────────────────────────┘
```

**Доступ:**
- Извне контейнера: `localhost:5432` или `127.0.0.1:5432`
- Из других контейнеров: `postgres:5432` (через Docker сеть)

**Альтернативные форматы:**
```yaml
# Явное указание протокола
- "5432:5432/tcp"

# Случайный порт на хосте
- "5432"  # Docker выберет свободный порт

# Диапазон портов
- "5432-5435:5432"
```

---

### Строки 11-12: `volumes:`
**Что делает:**
- Создает постоянное хранилище для данных БД
- Данные сохраняются даже после удаления контейнера

**Разбор:**
- `postgres_data` - имя volume (определяется в секции volumes)
- `/var/lib/postgresql/data` - путь внутри контейнера, где PostgreSQL хранит данные

**Зачем нужно:**
- Без volume: данные удаляются при удалении контейнера
- С volume: данные сохраняются между перезапусками

**Где хранятся данные:**
```bash
# Docker управляет volumes
docker volume ls
# DRIVER    VOLUME NAME
# local     backend_postgres_data

# Физическое расположение (Mac/Windows через Docker Desktop)
# ~/Library/Containers/com.docker.docker/Data/vms/0/data/docker/volumes/
```

**Процесс:**
```
1. Первый запуск:
   - Docker создает volume postgres_data
   - Монтирует его в /var/lib/postgresql/data
   - PostgreSQL инициализирует БД в этом месте

2. Перезапуск контейнера:
   - Docker монтирует тот же volume
   - PostgreSQL видит существующие данные
   - Продолжает работу с теми же данными

3. Удаление контейнера (без -v):
   - Контейнер удаляется
   - Volume остается
   - Данные сохраняются

4. Удаление с -v:
   - Контейнер удаляется
   - Volume удаляется
   - Данные теряются
```

---

### Строки 13-17: `healthcheck:`
**Что делает:**
- Определяет способ проверки здоровья контейнера
- Docker периодически проверяет, работает ли сервис корректно

**Разбор каждой строки:**

#### `test: ["CMD-SHELL", "pg_isready -U postgres -d dashboard"]`
- Команда для проверки здоровья
- `CMD-SHELL` - выполнить команду через shell
- `pg_isready` - утилита PostgreSQL для проверки готовности
- `-U postgres` - пользователь для подключения
- `-d dashboard` - база данных для проверки

**Что делает pg_isready:**
- Проверяет, принимает ли PostgreSQL соединения
- Возвращает код 0 если готов, не-0 если не готов

#### `interval: 10s`
- Интервал между проверками
- Каждые 10 секунд Docker выполняет healthcheck

#### `timeout: 5s`
- Максимальное время ожидания ответа
- Если команда не завершилась за 5 секунд - считается неудачной

#### `retries: 5`
- Количество неудачных попыток перед пометкой как "unhealthy"
- После 5 неудачных проверок контейнер помечается как нездоровый

**Статусы контейнера:**
```
starting → healthy
   ↓
unhealthy (после 5 неудачных проверок)
```

**Зачем нужно:**
- `depends_on` с `condition: service_healthy` ждет, пока контейнер станет healthy
- Гарантирует, что PostgreSQL готов принимать соединения перед запуском backend

---

### Строки 18-19: `networks:`
**Что делает:**
- Подключает сервис к Docker сети
- Сервисы в одной сети могут общаться друг с другом по имени

**Разбор:**
- `finance-network` - имя сети (определяется в секции networks)
- Сервисы в одной сети могут обращаться друг к другу по имени сервиса

**Как это работает:**
```
┌─────────────────────────────────────┐
│  Docker сеть: finance-network       │
│                                      │
│  ┌──────────────┐    ┌───────────┐  │
│  │  postgres    │    │  backend  │  │
│  │  :5432       │◄───┤           │  │
│  └──────────────┘    └───────────┘  │
│                                      │
└─────────────────────────────────────┘
```

**Обращение между сервисами:**
- Backend может подключиться к PostgreSQL по адресу: `postgres:5432`
- Не нужно использовать `localhost` или IP адреса
- Docker DNS автоматически разрешает имя `postgres` в IP контейнера

**Без сети:**
- Сервисы не могут общаться друг с другом
- Нужно использовать `network_mode: host` или внешние сети

---

## СЕРВИС 2: Backend

### Строка 21: `backend:`
**Что делает:**
- Определяет сервис для вашего Go приложения
- Имя сервиса используется как hostname в сети

---

### Строки 22-24: `build:`
**Что делает:**
- Указывает Docker Compose собрать образ из Dockerfile вместо использования готового образа

**Разбор:**

#### `context: .`
- Контекст сборки - директория, где находится Dockerfile
- `.` означает текущую директорию (где находится docker-compose.yml)
- Все файлы из этой директории доступны для COPY в Dockerfile

**Что такое контекст:**
```
backend/                    # context: .
├── docker-compose.yml
├── Dockerfile
├── go.mod
├── cmd/
│   └── main.go
└── internal/
    └── ...
```
Все эти файлы доступны в Dockerfile.

#### `dockerfile: Dockerfile`
- Имя файла Dockerfile для сборки
- По умолчанию ищет `Dockerfile` в context директории
- Можно указать другой файл: `dockerfile: Dockerfile.prod`

**Процесс сборки:**
```
docker-compose up
→ Читает build: context и dockerfile
→ Выполняет: docker build -f Dockerfile .
→ Создает образ с именем: backend_backend (проект_сервис)
→ Запускает контейнер из этого образа
```

---

### Строка 25: `container_name: finance-dashboard-backend`
**Что делает:**
- Задает имя контейнера (аналогично postgres сервису)
- Без этого было бы: `backend_backend_1`

---

### Строки 26-27: `ports:`
**Что делает:**
- Пробрасывает порт 3000 из контейнера на хост

**Разбор:**
- `"3000:3000"` - порт хоста:порт контейнера
- Backend слушает на порту 3000 внутри контейнера
- Доступен на `localhost:3000` с вашей машины

**Доступ к приложению:**
```bash
# С вашего компьютера
curl http://localhost:3000/ping

# Из другого контейнера (в той же сети)
curl http://backend:3000/ping
```

---

### Строки 28-33: `environment:`
**Что делает:**
- Устанавливает переменные окружения для backend приложения
- Эти переменные доступны в Go коде через `os.Getenv()`

**Разбор переменных:**

#### `DB_HOST=postgres`
- Хост базы данных
- `postgres` - имя сервиса в docker-compose (автоматически резолвится в IP)

**Почему `postgres`, а не `localhost`:**
- `localhost` внутри контейнера = сам контейнер
- `postgres` = имя другого контейнера в Docker сети
- Docker DNS автоматически преобразует `postgres` в IP адрес контейнера

#### `DB_PORT=5432`
- Порт PostgreSQL (стандартный порт)

#### `DB_USER=postgres`
- Имя пользователя для подключения к БД
- Должно совпадать с `POSTGRES_USER` в postgres сервисе

#### `DB_PASSWORD=postgres`
- Пароль для подключения к БД
- Должно совпадать с `POSTGRES_PASSWORD` в postgres сервисе

#### `DB_NAME=dashboard`
- Имя базы данных
- Должно совпадать с `POSTGRES_DB` в postgres сервисе

**Как использовать в Go:**
```go
dbHost := os.Getenv("DB_HOST")      // "postgres"
dbPort := os.Getenv("DB_PORT")      // "5432"
dbUser := os.Getenv("DB_USER")      // "postgres"
dbPassword := os.Getenv("DB_PASSWORD") // "postgres"
dbName := os.Getenv("DB_NAME")      // "dashboard"

// Строка подключения
dsn := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s",
    dbHost, dbPort, dbUser, dbPassword, dbName)
```

---

### Строки 34-36: `depends_on:`
**Что делает:**
- Определяет зависимости между сервисами
- Backend не запустится, пока postgres не будет готов

**Разбор:**

#### `postgres:`
- Зависит от сервиса `postgres`
- Docker Compose сначала запустит postgres, потом backend

#### `condition: service_healthy`
- Условие запуска: ждет, пока postgres станет healthy
- Без этого условия backend запустится сразу после старта postgres
- С условием - ждет успешного healthcheck

**Без condition:**
```
1. Запускается postgres (но еще не готов)
2. Сразу запускается backend
3. Backend пытается подключиться → ошибка!
```

**С condition: service_healthy:**
```
1. Запускается postgres
2. Healthcheck проверяет готовность
3. После успешных проверок postgres = healthy
4. Только теперь запускается backend
5. Backend подключается → успех!
```

**Альтернативные условия:**
```yaml
depends_on:
  postgres:
    condition: service_started    # Ждет только запуска (не готовности)
    condition: service_healthy     # Ждет готовности (рекомендуется)
    condition: service_completed_successfully  # Для одноразовых задач
```

---

### Строки 37-38: `networks:`
**Что делает:**
- Подключает backend к той же сети, что и postgres
- Позволяет обращаться к postgres по имени

**Важно:** Оба сервиса должны быть в одной сети для общения!

---

### Строка 39: `restart: unless-stopped`
**Что делает:**
- Политика перезапуска контейнера при сбоях

**Разбор:**
- `unless-stopped` - перезапускать всегда, кроме случаев:
  - Контейнер был явно остановлен (`docker-compose stop`)
  - Docker daemon был остановлен, а контейнер был остановлен

**Альтернативные политики:**
```yaml
restart: no              # Не перезапускать (по умолчанию)
restart: always          # Всегда перезапускать
restart: on-failure      # Перезапускать только при ошибке
restart: unless-stopped  # Перезапускать, если не остановлен вручную
```

**Примеры:**
```
1. Контейнер упал с ошибкой → автоматически перезапустится
2. Вы остановили: docker-compose stop → не перезапустится
3. Перезагрузка сервера → перезапустится (если Docker запустился)
```

---

## СЕКЦИЯ VOLUMES

### Строки 41-42: `volumes:`
**Что делает:**
- Определяет именованные volumes для хранения данных

**Разбор:**
- `postgres_data:` - имя volume
- Пустое значение после `:` означает использование драйвера по умолчанию (local)

**Что создается:**
- Docker создает volume с именем `backend_postgres_data`
- Префикс `backend` - имя проекта (имя директории или из COMPOSE_PROJECT_NAME)

**Управление volumes:**
```bash
# Список volumes
docker volume ls

# Информация о volume
docker volume inspect backend_postgres_data

# Удаление volume (удалит все данные!)
docker volume rm backend_postgres_data
```

**Альтернативные форматы:**
```yaml
volumes:
  # Именованный volume (управляется Docker)
  postgres_data:
  
  # Bind mount (монтирует директорию с хоста)
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /path/to/data
  
  # Внешний volume (уже существующий)
  postgres_data:
    external: true
    name: my_existing_volume
```

---

## СЕКЦИЯ NETWORKS

### Строки 44-46: `networks:`
**Что делает:**
- Определяет Docker сети для сервисов

**Разбор:**
- `finance-network:` - имя сети
- `driver: bridge` - тип сетевого драйвера

**Типы драйверов:**
- `bridge` - стандартная сеть (по умолчанию)
  - Изолированная сеть для контейнеров
  - Контейнеры могут общаться друг с другом
  - Не доступна с хоста напрямую
  
- `host` - использует сеть хоста
  - Контейнеры используют сетевой стек хоста
  - Нет изоляции сети
  
- `overlay` - для Docker Swarm (кластер)
  - Сеть между несколькими хостами

**Что создается:**
- Docker создает сеть: `backend_finance-network`
- Все сервисы, указавшие эту сеть, могут общаться

**Управление сетями:**
```bash
# Список сетей
docker network ls

# Информация о сети
docker network inspect backend_finance-network

# Удаление сети
docker network rm backend_finance-network
```

---

## ВИЗУАЛИЗАЦИЯ АРХИТЕКТУРЫ

```
┌─────────────────────────────────────────────────────────┐
│  Docker Host (ваш компьютер)                             │
│                                                          │
│  ┌──────────────────────────────────────────────────┐  │
│  │  Docker Network: finance-network                  │  │
│  │                                                   │  │
│  │  ┌──────────────────┐      ┌──────────────────┐ │  │
│  │  │  postgres        │      │  backend         │ │  │
│  │  │  Container       │      │  Container       │ │  │
│  │  │                  │      │                  │ │  │
│  │  │  Port: 5432      │◄─────┤  Port: 3000      │ │  │
│  │  │  (внутри)        │      │  (внутри)        │ │  │
│  │  │                  │      │                  │ │  │
│  │  │  Volume:         │      │  Env vars:       │ │  │
│  │  │  /var/lib/...    │      │  DB_HOST=postgres│ │  │
│  │  └──────────────────┘      └──────────────────┘ │  │
│  └──────────────────────────────────────────────────┘  │
│                                                          │
│  Проброс портов:                                         │
│  localhost:5432 ────► postgres:5432                     │
│  localhost:3000 ────► backend:3000                      │
│                                                          │
│  Volume:                                                 │
│  postgres_data ────► /var/lib/postgresql/data           │
└─────────────────────────────────────────────────────────┘
```

---

## ПОЛНЫЙ ЖИЗНЕННЫЙ ЦИКЛ

### 1. Запуск (`docker-compose up`)
```
1. Docker Compose читает docker-compose.yml
2. Создает сеть: finance-network
3. Создает volume: postgres_data
4. Запускает postgres контейнер:
   - Инициализирует БД (если первый раз)
   - Устанавливает пользователя и пароль
   - Создает базу dashboard
   - Запускает healthcheck
5. Ждет, пока postgres станет healthy
6. Собирает образ backend (если нужно)
7. Запускает backend контейнер:
   - Устанавливает переменные окружения
   - Подключается к postgres:5432
   - Запускает приложение на порту 3000
```

### 2. Работа
```
- Backend обращается к PostgreSQL по адресу postgres:5432
- Данные сохраняются в volume postgres_data
- Healthcheck периодически проверяет postgres
- При сбое backend автоматически перезапускается
```

### 3. Остановка (`docker-compose stop`)
```
- Останавливает контейнеры
- Данные остаются в volumes
- Сеть остается
```

### 4. Удаление (`docker-compose down`)
```
- Останавливает контейнеры
- Удаляет контейнеры
- Удаляет сеть
- Volumes остаются (данные сохраняются)
```

### 5. Полное удаление (`docker-compose down -v`)
```
- Все как в пункте 4
- ПЛЮС удаляет volumes
- ВСЕ ДАННЫЕ УДАЛЯЮТСЯ!
```

---

## КОМАНДЫ ДЛЯ РАБОТЫ

### Запуск
```bash
# Запуск в фоне
docker-compose up -d

# Запуск с логами
docker-compose up

# Пересборка и запуск
docker-compose up --build
```

### Остановка
```bash
# Остановка
docker-compose stop

# Остановка и удаление контейнеров
docker-compose down

# Остановка с удалением volumes (ОПАСНО!)
docker-compose down -v
```

### Просмотр
```bash
# Список контейнеров
docker-compose ps

# Логи всех сервисов
docker-compose logs

# Логи конкретного сервиса
docker-compose logs postgres
docker-compose logs backend

# Логи в реальном времени
docker-compose logs -f
```

### Выполнение команд
```bash
# Выполнить команду в контейнере
docker-compose exec postgres psql -U postgres -d dashboard

# Выполнить команду в новом контейнере
docker-compose run backend sh
```

---

## ВАЖНЫЕ МОМЕНТЫ

1. **Имена сервисов = hostnames**
   - `postgres` в docker-compose → hostname `postgres` в сети
   - Backend подключается к `postgres:5432`, а не `localhost:5432`

2. **Volumes сохраняют данные**
   - При `docker-compose down` данные остаются
   - При `docker-compose down -v` данные удаляются

3. **Healthcheck важен для depends_on**
   - Без healthcheck backend может запуститься до готовности postgres
   - С `condition: service_healthy` ждет готовности

4. **Сеть изолирует сервисы**
   - Сервисы в одной сети могут общаться
   - Сервисы в разных сетях - нет

5. **Переменные окружения**
   - Доступны в коде через `os.Getenv()`
   - Можно переопределить через `.env` файл или `-e` флаг

---

## БЕЗОПАСНОСТЬ

### Что НЕ делать в продакшене:
```yaml
# ❌ Плохо: пароли в открытом виде
POSTGRES_PASSWORD: postgres

# ✅ Хорошо: использовать секреты
POSTGRES_PASSWORD_FILE: /run/secrets/postgres_password
```

### Использование секретов:
```yaml
services:
  postgres:
    secrets:
      - postgres_password
    environment:
      POSTGRES_PASSWORD_FILE: /run/secrets/postgres_password

secrets:
  postgres_password:
    file: ./secrets/postgres_password.txt
```

---

Это полное объяснение структуры docker-compose.yml. Каждая строка играет важную роль в создании рабочей инфраструктуры!

